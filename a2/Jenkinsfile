pipeline {
    agent { label 'jenkins-agent' }

    environment {
        // Define the application name (user/repo)
        APP_IMAGE_NAME = 'ravinderjit/assignment2'
        
        // Tools and Credentials
        DOCKER_BIN = '/usr/bin/docker'
        KUBECTL_BIN = '/usr/local/bin/kubectl'
        DOCKER_CREDS_ID = 'dockerhub-creds'
        
        // Kubernetes Configuration Variables
        K8S_NAMESPACE = 'rgill201' // Matches the namespace in k8s-manifest.yaml
        K8S_MANIFEST_FILE = 'k8s-manifest.yaml' // Assuming manifest is in the a2 subdirectory
        K8S_DEPLOYMENT_NAME = 'a2-deployment' // Name of the Deployment resource to check rollout status
    }

    stages {
        stage('Clone Source Code') {
            steps {
                // Clones the repo containing the Jenkinsfile and the application source code/manifests
                checkout scm
            }
        }

        stage('Build Image') {
            steps {
                // Use the unique BUILD_NUMBER for versioning in Docker Hub and Kubernetes
                dir('a2') {
                    sh "${DOCKER_BIN} build -t ${APP_IMAGE_NAME}:latest ."
                }
            }
        }
        
        stage('Push to Docker Hub') {
            steps {
                withCredentials([usernamePassword(credentialsId: DOCKER_CREDS_ID,
                                                 usernameVariable: 'DOCKER_USER_VAR',
                                                 passwordVariable: 'DOCKER_PASS_VAR')]) {
                    sh """
                        echo 'Logging into Docker Hub...'                        
                        echo "$DOCKER_PASS_VAR" | ${DOCKER_BIN} login -u $DOCKER_USER_VAR --password-stdin
                        
                        echo 'Pushing image to Docker Hub...'
                        ${DOCKER_BIN} push ${APP_IMAGE_NAME}:latest
                        
                        ${DOCKER_BIN} logout
                    """
                }
            }
        }

        stage('Deploy to K8s') {
            steps {
                dir('a2') {
                    sh "echo 'Reapplying RBAC configuration to bypass GET deadlock...'"
                    
                    // 1. DELETE: Use the guaranteed fail-safe delete flag
                    // This command will attempt to delete the old RoleBinding, but if it exists 
                    // and fails due to permission denied, we still need to proceed.
                    // Since the previous log showed delete failed, we rely on the create/apply logic below.
                    sh "${KUBECTL_BIN} delete rolebinding jenkins-rgill201-binding -n ${K8S_NAMESPACE} --ignore-not-found=true || true"


                    // 2. APPLY RBAC: Use 'create' for the first time, as it skips the 'get' check
                    // This should succeed because the object is already deleted, OR it fails the RBAC check.
                    sh "echo 'Attempting to create RoleBinding...'"
                    sh "${KUBECTL_BIN} create -f rbac-fix.yaml -n ${K8S_NAMESPACE}"

                    // 3. APPLY APPLICATION MANIFESTS
                    sh "echo 'Applying K8s manifest for deployment ${K8S_DEPLOYMENT_NAME}'"
                    
                    // Use 'apply' for the application manifests, but use the cluster-admin's power.
                    sh "${KUBECTL_BIN} apply -f ${K8S_MANIFEST_FILE} -n ${K8S_NAMESPACE}"
                    
                    // 4. Wait for the rolling update to complete
                    sh "${KUBECTL_BIN} rollout status deployment/${K8S_DEPLOYMENT_NAME} -n ${K8S_NAMESPACE}"
                }
            }
        }
    }

    post {
        failure {
            sh "echo 'Pipeline failed. Check build logs for errors.'"
        }
        success {
            sh "echo 'Application deployed to K8s. Access via http://localhost:30000'"
        }
    }
}